{
  "version": 3,
  "sources": ["../../shepherd.js/node_modules/deepmerge/dist/cjs.js", "../../shepherd.js/src/js/utils/type-check.js", "../../shepherd.js/src/js/evented.js", "../../shepherd.js/src/js/utils/auto-bind.js", "../../shepherd.js/src/js/utils/bind.js", "../../shepherd.js/src/js/utils/general.js", "../../shepherd.js/node_modules/@floating-ui/utils/dist/floating-ui.utils.esm.js", "../../shepherd.js/node_modules/@floating-ui/core/dist/floating-ui.core.esm.js", "../../shepherd.js/node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.esm.js", "../../shepherd.js/node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js", "../../shepherd.js/src/js/utils/floating-ui.js", "../../shepherd.js/node_modules/svelte/internal/index.mjs", "../../shepherd.js/src/js/components/shepherd-button.svelte", "../../shepherd.js/src/js/components/shepherd-footer.svelte", "../../shepherd.js/src/js/components/shepherd-cancel-icon.svelte", "../../shepherd.js/src/js/components/shepherd-title.svelte", "../../shepherd.js/src/js/components/shepherd-header.svelte", "../../shepherd.js/src/js/components/shepherd-text.svelte", "../../shepherd.js/src/js/components/shepherd-content.svelte", "../../shepherd.js/src/js/components/shepherd-element.svelte", "../../shepherd.js/src/js/step.js", "../../shepherd.js/src/js/utils/cleanup.js", "../../shepherd.js/src/js/utils/overlay-path.js", "../../shepherd.js/src/js/components/shepherd-modal.svelte", "../../shepherd.js/src/js/tour.js", "../../shepherd.js/src/js/shepherd.js"],
  "sourcesContent": ["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "/**\n * Checks if `value` is classified as an `Element`.\n * @param {*} value The param to check if it is an Element\n */\nexport function isElement(value) {\n  return value instanceof Element;\n}\n\n/**\n * Checks if `value` is classified as an `HTMLElement`.\n * @param {*} value The param to check if it is an HTMLElement\n */\nexport function isHTMLElement(value) {\n  return value instanceof HTMLElement;\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n * @param {*} value The param to check if it is a function\n */\nexport function isFunction(value) {\n  return typeof value === 'function';\n}\n\n/**\n * Checks if `value` is classified as a `String` object.\n * @param {*} value The param to check if it is a string\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * Checks if `value` is undefined.\n * @param {*} value The param to check if it is undefined\n */\nexport function isUndefined(value) {\n  return value === undefined;\n}\n", "import { isUndefined } from './utils/type-check';\n\nexport class Evented {\n  on(event, handler, ctx, once = false) {\n    if (isUndefined(this.bindings)) {\n      this.bindings = {};\n    }\n    if (isUndefined(this.bindings[event])) {\n      this.bindings[event] = [];\n    }\n    this.bindings[event].push({ handler, ctx, once });\n\n    return this;\n  }\n\n  once(event, handler, ctx) {\n    return this.on(event, handler, ctx, true);\n  }\n\n  off(event, handler) {\n    if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n      return this;\n    }\n\n    if (isUndefined(handler)) {\n      delete this.bindings[event];\n    } else {\n      this.bindings[event].forEach((binding, index) => {\n        if (binding.handler === handler) {\n          this.bindings[event].splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  trigger(event, ...args) {\n    if (!isUndefined(this.bindings) && this.bindings[event]) {\n      this.bindings[event].forEach((binding, index) => {\n        const { ctx, handler, once } = binding;\n\n        const context = ctx || this;\n\n        handler.apply(context, args);\n\n        if (once) {\n          this.bindings[event].splice(index, 1);\n        }\n      });\n    }\n\n    return this;\n  }\n}\n", "/**\n * Binds all the methods on a JS Class to the `this` context of the class.\n * Adapted from https://github.com/sindresorhus/auto-bind\n * @param {object} self The `this` context of the class\n * @return {object} The `this` context of the class\n */\nexport default function autoBind(self) {\n  const keys = Object.getOwnPropertyNames(self.constructor.prototype);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const val = self[key];\n    if (key !== 'constructor' && typeof val === 'function') {\n      self[key] = val.bind(self);\n    }\n  }\n\n  return self;\n}\n", "import { isUndefined } from './type-check';\n\n/**\n * Sets up the handler to determine if we should advance the tour\n * @param {string} selector\n * @param {Step} step The step instance\n * @return {Function}\n * @private\n */\nfunction _setupAdvanceOnHandler(selector, step) {\n  return (event) => {\n    if (step.isOpen()) {\n      const targetIsEl = step.el && event.currentTarget === step.el;\n      const targetIsSelector =\n        !isUndefined(selector) && event.currentTarget.matches(selector);\n\n      if (targetIsSelector || targetIsEl) {\n        step.tour.next();\n      }\n    }\n  };\n}\n\n/**\n * Bind the event handler for advanceOn\n * @param {Step} step The step instance\n */\nexport function bindAdvance(step) {\n  // An empty selector matches the step element\n  const { event, selector } = step.options.advanceOn || {};\n  if (event) {\n    const handler = _setupAdvanceOnHandler(selector, step);\n\n    // TODO: this should also bind/unbind on show/hide\n    let el;\n    try {\n      el = document.querySelector(selector);\n    } catch (e) {\n      // TODO\n    }\n    if (!isUndefined(selector) && !el) {\n      return console.error(\n        `No element was found for the selector supplied to advanceOn: ${selector}`\n      );\n    } else if (el) {\n      el.addEventListener(event, handler);\n      step.on('destroy', () => {\n        return el.removeEventListener(event, handler);\n      });\n    } else {\n      document.body.addEventListener(event, handler, true);\n      step.on('destroy', () => {\n        return document.body.removeEventListener(event, handler, true);\n      });\n    }\n  } else {\n    return console.error(\n      'advanceOn was defined, but no event name was passed.'\n    );\n  }\n}\n", "import { isFunction, isString } from './type-check';\n\n/**\n * Ensure class prefix ends in `-`\n * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n * @return {string} The prefix ending in `-`\n */\nexport function normalizePrefix(prefix) {\n  if (!isString(prefix) || prefix === '') {\n    return '';\n  }\n\n  return prefix.charAt(prefix.length - 1) !== '-' ? `${prefix}-` : prefix;\n}\n\n/**\n * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n * @param {Step} step The step instance\n * @returns {{}|{element, on}}\n * `element` is a qualified HTML Element\n * `on` is a string position value\n */\nexport function parseAttachTo(step) {\n  const options = step.options.attachTo || {};\n  const returnOpts = Object.assign({}, options);\n\n  if (isFunction(returnOpts.element)) {\n    // Bind the callback to step so that it has access to the object, to enable running additional logic\n    returnOpts.element = returnOpts.element.call(step);\n  }\n\n  if (isString(returnOpts.element)) {\n    // Can't override the element in user opts reference because we can't\n    // guarantee that the element will exist in the future.\n    try {\n      returnOpts.element = document.querySelector(returnOpts.element);\n    } catch (e) {\n      // TODO\n    }\n    if (!returnOpts.element) {\n      console.error(\n        `The element for this Shepherd step was not found ${options.element}`\n      );\n    }\n  }\n\n  return returnOpts;\n}\n\n/**\n * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n * alternative for the deprecated step.isCentered() method.\n * @param resolvedAttachToOptions\n * @returns {boolean}\n */\nexport function shouldCenterStep(resolvedAttachToOptions) {\n  if (\n    resolvedAttachToOptions === undefined ||\n    resolvedAttachToOptions === null\n  ) {\n    return true;\n  }\n\n  return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n}\n\n/**\n * Create a unique id for steps, tours, modals, etc\n * @return {string}\n */\nexport function uuid() {\n  let d = Date.now();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n", "const sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. This stops `shift()` from taking action, but can\n    // be worked around by calling it again after the `arrow()` if desired.\n    const shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? min$1 - center : max - center : 0;\n    return {\n      [axis]: coords[axis] - alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset + alignmentOffset\n      }\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n", "import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { autoUpdate, computePosition, platform };\n", "import merge from 'deepmerge';\nimport { shouldCenterStep } from './general';\nimport {\n  autoUpdate,\n  arrow,\n  computePosition,\n  flip,\n  limitShift,\n  shift\n} from '@floating-ui/dom';\n\n/**\n * Floating UI Options\n *\n * @typedef {object} FloatingUIOptions\n */\n\n/**\n * Determines options for the tooltip and initializes event listeners.\n *\n * @param {Step} step The step instance\n *\n * @return {FloatingUIOptions}\n */\nexport function setupTooltip(step) {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  const attachToOptions = step._getResolvedAttachToOptions();\n\n  let target = attachToOptions.element;\n  const floatingUIOptions = getFloatingUIOptions(attachToOptions, step);\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  if (shouldCenter) {\n    target = document.body;\n    const content = step.shepherdElementComponent.getElement();\n    content.classList.add('shepherd-centered');\n  }\n\n  step.cleanup = autoUpdate(target, step.el, () => {\n    // The element might have already been removed by the end of the tour.\n    if (!step.el) {\n      step.cleanup();\n      return;\n    }\n\n    setPosition(target, step, floatingUIOptions, shouldCenter);\n  });\n\n  step.target = attachToOptions.element;\n\n  return floatingUIOptions;\n}\n\n/**\n * Merge tooltip options handling nested keys.\n *\n * @param tourOptions - The default tour options.\n * @param options - Step specific options.\n *\n * @return {floatingUIOptions: FloatingUIOptions}\n */\nexport function mergeTooltipConfig(tourOptions, options) {\n  return {\n    floatingUIOptions: merge(\n      tourOptions.floatingUIOptions || {},\n      options.floatingUIOptions || {}\n    )\n  };\n}\n\n/**\n * Cleanup function called when the step is closed/destroyed.\n *\n * @param {Step} step\n */\nexport function destroyTooltip(step) {\n  if (step.cleanup) {\n    step.cleanup();\n  }\n\n  step.cleanup = null;\n}\n\n/**\n *\n * @return {Promise<*>}\n */\nfunction setPosition(target, step, floatingUIOptions, shouldCenter) {\n  return (\n    computePosition(target, step.el, floatingUIOptions)\n      .then(floatingUIposition(step, shouldCenter))\n      // Wait before forcing focus.\n      .then(\n        (step) =>\n          new Promise((resolve) => {\n            setTimeout(() => resolve(step), 300);\n          })\n      )\n      // Replaces focusAfterRender modifier.\n      .then((step) => {\n        if (step && step.el) {\n          step.el.focus({ preventScroll: true });\n        }\n      })\n  );\n}\n\n/**\n *\n * @param step\n * @param shouldCenter\n * @return {function({x: *, y: *, placement: *, middlewareData: *}): Promise<unknown>}\n */\nfunction floatingUIposition(step, shouldCenter) {\n  return ({ x, y, placement, middlewareData }) => {\n    if (!step.el) {\n      return step;\n    }\n\n    if (shouldCenter) {\n      Object.assign(step.el.style, {\n        position: 'fixed',\n        left: '50%',\n        top: '50%',\n        transform: 'translate(-50%, -50%)'\n      });\n    } else {\n      Object.assign(step.el.style, {\n        position: 'absolute',\n        left: `${x}px`,\n        top: `${y}px`\n      });\n    }\n\n    step.el.dataset.popperPlacement = placement;\n\n    placeArrow(step.el, middlewareData);\n\n    return step;\n  };\n}\n\n/**\n *\n * @param el\n * @param middlewareData\n */\nfunction placeArrow(el, middlewareData) {\n  const arrowEl = el.querySelector('.shepherd-arrow');\n  if (arrowEl && middlewareData.arrow) {\n    const { x: arrowX, y: arrowY } = middlewareData.arrow;\n    Object.assign(arrowEl.style, {\n      left: arrowX != null ? `${arrowX}px` : '',\n      top: arrowY != null ? `${arrowY}px` : ''\n    });\n  }\n}\n\n/**\n * Gets the `Floating UI` options from a set of base `attachTo` options\n * @param attachToOptions\n * @param {Step} step The step instance\n * @return {Object}\n * @private\n */\nexport function getFloatingUIOptions(attachToOptions, step) {\n  const options = {\n    strategy: 'absolute',\n    middleware: []\n  };\n\n  const arrowEl = addArrow(step);\n\n  const shouldCenter = shouldCenterStep(attachToOptions);\n\n  if (!shouldCenter) {\n    options.middleware.push(\n      flip(),\n      // Replicate PopperJS default behavior.\n      shift({\n        limiter: limitShift(),\n        crossAxis: true\n      })\n    );\n\n    if (arrowEl) {\n      options.middleware.push(arrow({ element: arrowEl }));\n    }\n\n    options.placement = attachToOptions.on;\n  }\n\n  return merge(step.options.floatingUIOptions || {}, options);\n}\n\n/**\n * @param {Step} step\n * @return {HTMLElement|false|null}\n */\nfunction addArrow(step) {\n  if (step.options.arrow && step.el) {\n    return step.el.querySelector('.shepherd-arrow');\n  }\n\n  return false;\n}\n", "function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\nfunction is_promise(value) {\n    return !!value && (typeof value === 'object' || typeof value === 'function') && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\nfunction split_css_unit(value) {\n    const split = typeof value === 'string' && value.match(/^\\s*(-?[\\d.]+)([^\\s]*)\\s*$/);\n    return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];\n}\nconst contenteditable_truthy_values = ['', true, 1, 'true', 'contenteditable'];\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n    constructor(options) {\n        this.options = options;\n        this._listeners = 'WeakMap' in globals ? new WeakMap() : undefined;\n    }\n    observe(element, listener) {\n        this._listeners.set(element, listener);\n        this._getObserver().observe(element, this.options);\n        return () => {\n            this._listeners.delete(element);\n            this._observer.unobserve(element); // this line can probably be removed\n        };\n    }\n    _getObserver() {\n        var _a;\n        return (_a = this._observer) !== null && _a !== void 0 ? _a : (this._observer = new ResizeObserver((entries) => {\n            var _a;\n            for (const entry of entries) {\n                ResizeObserverSingleton.entries.set(entry.target, entry);\n                (_a = this._listeners.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n            }\n        }));\n    }\n}\n// Needs to be written like this to pass the tree-shake-test\nResizeObserverSingleton.entries = 'WeakMap' in globals ? new WeakMap() : undefined;\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element.sheet;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n    return style.sheet;\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentNode !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    if (node.parentNode) {\n        node.parentNode.removeChild(node);\n    }\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction comment(content) {\n    return document.createComment(content);\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_immediate_propagation(fn) {\n    return function (event) {\n        event.stopImmediatePropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\n/**\n * List of attributes that should always be set through the attr method,\n * because updating them through the property setter doesn't work reliably.\n * In the example of `width`/`height`, the problem is that the setter only\n * accepts numeric values, but the attribute can also be set to a string like `50%`.\n * If this list becomes too big, rethink this approach.\n */\nconst always_set_through_set_attribute = ['width', 'height'];\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data_map(node, data_map) {\n    Object.keys(data_map).forEach((key) => {\n        set_custom_element_data(node, key, data_map[key]);\n    });\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction set_dynamic_element_data(tag) {\n    return (/-/.test(tag)) ? set_custom_element_data_map : set_attributes;\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction init_binding_group(group) {\n    let _inputs;\n    return {\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            _inputs.forEach(input => group.push(input));\n        },\n        /* remove */ r() {\n            _inputs.forEach(input => group.splice(group.indexOf(input), 1));\n        }\n    };\n}\nfunction init_binding_group_dynamic(group, indexes) {\n    let _group = get_binding_group(group);\n    let _inputs;\n    function get_binding_group(group) {\n        for (let i = 0; i < indexes.length; i++) {\n            group = group[indexes[i]] = group[indexes[i]] || [];\n        }\n        return group;\n    }\n    function push() {\n        _inputs.forEach(input => _group.push(input));\n    }\n    function remove() {\n        _inputs.forEach(input => _group.splice(_group.indexOf(input), 1));\n    }\n    return {\n        /* update */ u(new_indexes) {\n            indexes = new_indexes;\n            const new_group = get_binding_group(group);\n            if (new_group !== _group) {\n                remove();\n                _group = new_group;\n                push();\n            }\n        },\n        /* push */ p(...inputs) {\n            _inputs = inputs;\n            push();\n        },\n        /* remove */ r: remove\n    };\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction claim_comment(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 8, (node) => {\n        node.data = '' + data;\n        return undefined;\n    }, () => comment(data), true);\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes, is_svg) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration(undefined, is_svg);\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index - start_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes, is_svg);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    text.data = data;\n}\nfunction set_data_contenteditable(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable(text, data);\n    }\n    else {\n        set_data(text, data);\n    }\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    if (value == null) {\n        node.style.removeProperty(key);\n    }\n    else {\n        node.style.setProperty(key, value, important ? 'important' : '');\n    }\n}\nfunction select_option(select, value, mounting) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    if (!mounting || value !== undefined) {\n        select.selectedIndex = -1; // no option should be selected\n    }\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked');\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_iframe_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n            // make sure an initial resize event is fired _after_ the iframe is loaded (which is asynchronous)\n            // see https://github.com/sveltejs/svelte/issues/4233\n            fn();\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nconst resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'content-box' });\nconst resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'border-box' });\nconst resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({ box: 'device-pixel-content-box' });\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, cancelable, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nfunction head_selector(nodeId, head) {\n    const result = [];\n    let started = 0;\n    for (const node of head.childNodes) {\n        if (node.nodeType === 8 /* comment node */) {\n            const comment = node.textContent.trim();\n            if (comment === `HEAD_${nodeId}_END`) {\n                started -= 1;\n                result.push(node);\n            }\n            else if (comment === `HEAD_${nodeId}_START`) {\n                started += 1;\n                result.push(node);\n            }\n        }\n        else if (started > 0) {\n            result.push(node);\n        }\n    }\n    return result;\n}\nclass HtmlTag {\n    constructor(is_svg = false) {\n        this.is_svg = false;\n        this.is_svg = is_svg;\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            if (this.is_svg)\n                this.e = svg_element(target.nodeName);\n            /** #7364  target for <template> may be provided as #document-fragment(11) */\n            else\n                this.e = element((target.nodeType === 11 ? 'TEMPLATE' : target.nodeName));\n            this.t = target.tagName !== 'TEMPLATE' ? target : target.content;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.nodeName === 'TEMPLATE' ? this.e.content.childNodes : this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes, is_svg = false) {\n        super(is_svg);\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\nfunction construct_svelte_component(component, props) {\n    return new component(props);\n}\n\n// we need to store the information for multiple documents because a Svelte application could also contain iframes\n// https://github.com/sveltejs/svelte/issues/3624\nconst managed_styles = new Map();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_style_information(doc, node) {\n    const info = { stylesheet: append_empty_stylesheet(node), rules: {} };\n    managed_styles.set(doc, info);\n    return info;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);\n    if (!rules[name]) {\n        rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        managed_styles.forEach(info => {\n            const { ownerNode } = info.stylesheet;\n            // there is no ownerNode if it runs on jsdom.\n            if (ownerNode)\n                detach(ownerNode);\n        });\n        managed_styles.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`\n *\n * https://svelte.dev/docs#run-time-svelte-beforeupdate\n */\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).\n *\n * https://svelte.dev/docs#run-time-svelte-onmount\n */\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`\n */\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * https://svelte.dev/docs#run-time-svelte-ondestroy\n */\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * https://svelte.dev/docs#run-time-svelte-createeventdispatcher\n */\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail, { cancelable = false } = {}) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail, { cancelable });\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n            return !event.defaultPrevented;\n        }\n        return true;\n    };\n}\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-setcontext\n */\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n    return context;\n}\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-getcontext\n */\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs#run-time-svelte-getallcontexts\n */\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs#run-time-svelte-hascontext\n */\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nlet render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = /* @__PURE__ */ Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\n// flush() calls callbacks in this order:\n// 1. All beforeUpdate callbacks, in order: parents before children\n// 2. All bind:this callbacks, in reverse order: children before parents.\n// 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n//    for afterUpdates called during the initial onMount, which are called in\n//    reverse order: children before parents.\n// Since callbacks might update component values, which could trigger another\n// call to flush(), the following steps guard against this:\n// 1. During beforeUpdate, any updated components will be added to the\n//    dirty_components array and will cause a reentrant call to flush(). Because\n//    the flush index is kept outside the function, the reentrant call will pick\n//    up where the earlier call left off and go through all dirty components. The\n//    current_component value is saved and restored so that the reentrant call will\n//    not interfere with the \"parent\" flush() call.\n// 2. bind:this callbacks cannot trigger new flush() calls.\n// 3. During afterUpdate, any updated components will NOT have their afterUpdate\n//    callback called a second time; the seen_callbacks set, outside the flush()\n//    function, guarantees this behavior.\nconst seen_callbacks = new Set();\nlet flushidx = 0; // Do *not* move this inside the flush() function\nfunction flush() {\n    // Do not reenter flush while dirty components are updated, as this can\n    // result in an infinite loop. Instead, let the inner flush handle it.\n    // Reentrancy is ok afterwards for bindings etc.\n    if (flushidx !== 0) {\n        return;\n    }\n    const saved_component = current_component;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        try {\n            while (flushidx < dirty_components.length) {\n                const component = dirty_components[flushidx];\n                flushidx++;\n                set_current_component(component);\n                update(component.$$);\n            }\n        }\n        catch (e) {\n            // reset dirty state to not end up in a deadlocked state and then rethrow\n            dirty_components.length = 0;\n            flushidx = 0;\n            throw e;\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        flushidx = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n/**\n * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.\n */\nfunction flush_render_callbacks(fns) {\n    const filtered = [];\n    const targets = [];\n    render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n    targets.forEach((c) => c());\n    render_callbacks = filtered;\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n    else if (callback) {\n        callback();\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    const options = { direction: 'in' };\n    let config = fn(node, params, options);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config(options);\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    const options = { direction: 'out' };\n    let config = fn(node, params, options);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config(options);\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    const options = { direction: 'both' };\n    let config = fn(node, params, options);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config(options);\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    const updates = [];\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            // defer updates until all the DOM shuffling is done\n            updates.push(() => block.p(child_ctx, dirty));\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    run_all(updates);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\nconst _boolean_attributes = [\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'inert',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n];\n/**\n * List of HTML boolean attributes (e.g. `<input disabled>`).\n * Source: https://html.spec.whatwg.org/multipage/indices.html\n */\nconst boolean_attributes = new Set([..._boolean_attributes]);\n\n/** regex of all html void element names */\nconst void_element_names = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;\nfunction is_void(name) {\n    return void_element_names.test(name) || name.toLowerCase() === '!doctype';\n}\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, attrs_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (attrs_to_add) {\n        const classes_to_add = attrs_to_add.classes;\n        const styles_to_add = attrs_to_add.styles;\n        if (classes_to_add) {\n            if (attributes.class == null) {\n                attributes.class = classes_to_add;\n            }\n            else {\n                attributes.class += ' ' + classes_to_add;\n            }\n        }\n        if (styles_to_add) {\n            if (attributes.style == null) {\n                attributes.style = style_object_to_string(styles_to_add);\n            }\n            else {\n                attributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n            }\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nfunction merge_ssr_styles(style_attribute, style_directive) {\n    const style_object = {};\n    for (const individual_style of style_attribute.split(';')) {\n        const colon_index = individual_style.indexOf(':');\n        const name = individual_style.slice(0, colon_index).trim();\n        const value = individual_style.slice(colon_index + 1).trim();\n        if (!name)\n            continue;\n        style_object[name] = value;\n    }\n    for (const name in style_directive) {\n        const value = style_directive[name];\n        if (value) {\n            style_object[name] = value;\n        }\n        else {\n            delete style_object[name];\n        }\n    }\n    return style_object;\n}\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nfunction escape(value, is_attr = false) {\n    const str = String(value);\n    const pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n    pattern.lastIndex = 0;\n    let escaped = '';\n    let last = 0;\n    while (pattern.test(str)) {\n        const i = pattern.lastIndex - 1;\n        const ch = str[i];\n        escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n        last = i + 1;\n    }\n    return escaped + str.substring(last);\n}\nfunction escape_attribute_value(value) {\n    // keep booleans, null, and undefined for the sake of `spread`\n    const should_escape = typeof value === 'string' || (value && typeof value === 'object');\n    return should_escape ? escape(value, true) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    const assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n    return ` ${name}${assignment}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\nfunction style_object_to_string(style_object) {\n    return Object.keys(style_object)\n        .filter(key => style_object[key])\n        .map(key => `${key}: ${escape_attribute_value(style_object[key])};`)\n        .join(' ');\n}\nfunction add_styles(style_object) {\n    const styles = style_object_to_string(style_object);\n    return styles ? ` style=\"${styles}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n            // if the component was destroyed immediately\n            // it will update the `$$.on_destroy` reference to `null`.\n            // the destructured on_destroy may still reference to the old array\n            if (component.$$.on_destroy) {\n                component.$$.on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        flush_render_callbacks($$.after_update);\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: [],\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            if (!is_function(callback)) {\n                return noop;\n            }\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        if (!is_function(callback)) {\n            return noop;\n        }\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    if (has_stop_immediate_propagation)\n        modifiers.push('stopImmediatePropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.data === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_contenteditable_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction set_data_maybe_contenteditable_dev(text, data, attr_value) {\n    if (~contenteditable_truthy_values.indexOf(attr_value)) {\n        set_data_contenteditable_dev(text, data);\n    }\n    else {\n        set_data_dev(text, data);\n    }\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\nfunction validate_dynamic_element(tag) {\n    const is_string = typeof tag === 'string';\n    if (tag && !is_string) {\n        throw new Error('<svelte:element> expects \"this\" attribute to be a string.');\n    }\n}\nfunction validate_void_dynamic_element(tag) {\n    if (tag && is_void(tag)) {\n        console.warn(`<svelte:element this=\"${tag}\"> is self-closing and cannot have content.`);\n    }\n}\nfunction construct_svelte_component_dev(component, props) {\n    const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';\n    try {\n        const instance = new component(props);\n        if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {\n            throw new Error(error_message);\n        }\n        return instance;\n    }\n    catch (err) {\n        const { message } = err;\n        if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {\n            throw new Error(error_message);\n        }\n        else {\n            throw err;\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, ResizeObserverSingleton, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_iframe_resize_listener, add_location, add_render_callback, add_styles, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_comment, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, comment, component_subscribe, compute_rest_props, compute_slots, construct_svelte_component, construct_svelte_component_dev, contenteditable_truthy_values, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, flush_render_callbacks, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, head_selector, identity, init, init_binding_group, init_binding_group_dynamic, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, is_void, listen, listen_dev, loop, loop_guard, merge_ssr_styles, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, resize_observer_border_box, resize_observer_content_box, resize_observer_device_pixel_content_box, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_custom_element_data_map, set_data, set_data_contenteditable, set_data_contenteditable_dev, set_data_dev, set_data_maybe_contenteditable, set_data_maybe_contenteditable_dev, set_dynamic_element_data, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, split_css_unit, spread, src_url_equal, start_hydrating, stop_immediate_propagation, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_dynamic_element, validate_each_argument, validate_each_keys, validate_slots, validate_store, validate_void_dynamic_element, xlink_attr };\n", "<script>\n  import { isFunction } from '../utils/type-check';\n\n  export let config, step;\n  let action, classes, disabled, label, secondary, text;\n\n  $: {\n    action = config.action ? config.action.bind(step.tour) : null;\n    classes = config.classes;\n    disabled = config.disabled ? getConfigOption(config.disabled) : false;\n    label = config.label ? getConfigOption(config.label) : null;\n    secondary = config.secondary;\n    text = config.text ? getConfigOption(config.text) : null;\n  }\n\n  function getConfigOption(option) {\n    if (isFunction(option)) {\n      return option = option.call(step);\n    }\n    return option;\n  }\n\n</script>\n\n<style global>\n  .shepherd-button {\n    background: rgb(50, 136, 230);\n    border: 0;\n    border-radius: 3px;\n    color: rgba(255, 255, 255, 0.75);\n    cursor: pointer;\n    margin-right: 0.5rem;\n    padding: 0.5rem 1.5rem;\n    transition: all 0.5s ease;\n  }\n\n  .shepherd-button:not(:disabled):hover {\n    background: rgb(25, 111, 204);\n    color: rgba(255, 255, 255, 0.75);\n  }\n\n  .shepherd-button.shepherd-button-secondary {\n    background: rgb(241, 242, 243);\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-button.shepherd-button-secondary:not(:disabled):hover {\n    background: rgb(214, 217, 219);\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-button:disabled {\n    cursor: not-allowed;\n  }\n</style>\n\n<button\n  aria-label=\"{label ? label : null}\"\n  class=\"{`${(classes || '')} shepherd-button ${(secondary ? 'shepherd-button-secondary' : '')}`}\"\n  disabled={disabled}\n  on:click={action}\n  tabindex=\"0\"\n>\n    {@html text}\n</button>\n", "<script>\n  import ShepherdButton from './shepherd-button.svelte';\n\n  export let step;\n\n  $: buttons = step.options.buttons;\n</script>\n\n<style global>\n  .shepherd-footer {\n    border-bottom-left-radius: 5px;\n    border-bottom-right-radius: 5px;\n    display: flex;\n    justify-content: flex-end;\n    padding: 0 0.75rem 0.75rem;\n  }\n\n  .shepherd-footer .shepherd-button:last-child {\n    margin-right: 0;\n  }\n</style>\n\n<footer class=\"shepherd-footer\">\n    {#if buttons}\n        {#each buttons as config}\n          <ShepherdButton\n            {config}\n            {step}\n          />\n        {/each}\n    {/if}\n</footer>\n", "<script>\n  export let cancelIcon, step;\n\n  /**\n   * Add a click listener to the cancel link that cancels the tour\n   */\n  const handleCancelClick = (e) => {\n    e.preventDefault();\n    step.cancel();\n  };\n</script>\n\n<style global>\n  .shepherd-cancel-icon {\n    background: transparent;\n    border: none;\n    color: rgba(128, 128, 128, 0.75);\n    font-size: 2em;\n    cursor: pointer;\n    font-weight: normal;\n    margin: 0;\n    padding: 0;\n    transition: color 0.5s ease;\n  }\n\n  .shepherd-cancel-icon:hover {\n    color: rgba(0, 0, 0, 0.75);\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-cancel-icon {\n    color: rgba(128, 128, 128, 0.75);\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-cancel-icon:hover {\n    color: rgba(0, 0, 0, 0.75);\n  }\n</style>\n\n<button\n  aria-label=\"{cancelIcon.label ? cancelIcon.label : 'Close Tour'}\"\n  class=\"shepherd-cancel-icon\"\n  on:click={handleCancelClick}\n  type=\"button\"\n>\n  <span aria-hidden=\"true\">&times;</span>\n</button>\n", "<script>\n  import { afterUpdate } from 'svelte';\n  import { isFunction } from '../utils/type-check';\n  \n  export let labelId, element, title;\n  \n  afterUpdate(() => {\n    if (isFunction(title)) {\n      title = title();\n    }\n    \n    element.innerHTML = title;\n  });\n</script>\n\n<style global>\n  .shepherd-title {\n    color: rgba(0, 0, 0, 0.75);\n    display: flex;\n    font-size: 1rem;\n    font-weight: normal;\n    flex: 1 0 auto;\n    margin: 0;\n    padding: 0;\n  }\n</style>\n\n<h3\n  bind:this={element}\n  id=\"{labelId}\"\n  class=\"shepherd-title\"\n>\n</h3>\n", "<script>\n  import ShepherdCancelIcon from './shepherd-cancel-icon.svelte';\n  import ShepherdTitle from './shepherd-title.svelte';\n\n  export let labelId, step;\n  let title, cancelIcon;\n\n  $: {\n      title = step.options.title;\n      cancelIcon = step.options.cancelIcon;\n  }\n</script>\n\n<style global>\n  .shepherd-header {\n    align-items: center;\n    border-top-left-radius: 5px;\n    border-top-right-radius: 5px;\n    display: flex;\n    justify-content: flex-end;\n    line-height: 2em;\n    padding: 0.75rem 0.75rem 0;\n  }\n\n  .shepherd-has-title .shepherd-content .shepherd-header {\n    background: #e6e6e6;\n    padding: 1em;\n  }\n</style>\n\n<header class=\"shepherd-header\">\n    {#if title}\n      <ShepherdTitle\n        {labelId}\n        {title}\n      />\n    {/if}\n\n    {#if cancelIcon && cancelIcon.enabled}\n      <ShepherdCancelIcon\n        {cancelIcon}\n        {step}\n      />\n    {/if}\n</header>\n", "<script>\n  import { afterUpdate } from 'svelte';\n  import { isHTMLElement, isFunction } from '../utils/type-check';\n\n  export let descriptionId, element, step;\n\n  afterUpdate(() => {\n    let { text } = step.options;\n\n    if (isFunction(text)) {\n      text = text.call(step);\n    }\n\n    if (isHTMLElement(text)) {\n      element.appendChild(text);\n    } else {\n      element.innerHTML = text;\n    }\n  });\n</script>\n\n<style global>\n  .shepherd-text {\n    color: rgba(0, 0, 0, 0.75);\n    font-size: 1rem;\n    line-height: 1.3em;\n    padding: 0.75em;\n  }\n\n  .shepherd-text p {\n    margin-top: 0;\n  }\n\n  .shepherd-text p:last-child {\n    margin-bottom: 0;\n  }\n</style>\n\n<div\n  bind:this={element}\n  class=\"shepherd-text\"\n  id=\"{descriptionId}\"\n>\n</div>\n\n", "<script>\n  import ShepherdFooter from './shepherd-footer.svelte';\n  import ShepherdHeader from './shepherd-header.svelte';\n  import ShepherdText from './shepherd-text.svelte';\n  import { isUndefined } from '../utils/type-check.js';\n\n  export let descriptionId, labelId, step;\n</script>\n\n<style global>\n  .shepherd-content {\n    border-radius: 5px;\n    outline: none;\n    padding: 0;\n  }\n</style>\n\n<div\n  class=\"shepherd-content\"\n>\n  {#if !isUndefined(step.options.title) || (step.options.cancelIcon && step.options.cancelIcon.enabled)}\n    <ShepherdHeader\n      {labelId}\n      {step}\n    />\n  {/if}\n\n  {#if !isUndefined(step.options.text)}\n    <ShepherdText\n      {descriptionId}\n      {step}\n    />\n  {/if}\n\n  {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n    <ShepherdFooter\n      {step}\n    />\n  {/if}\n</div>\n", "<script>\n  import { onMount, afterUpdate } from 'svelte';\n  import ShepherdContent from './shepherd-content.svelte';\n  import { isUndefined, isString } from '../utils/type-check.js';\n\n  const KEY_TAB = 9;\n  const KEY_ESC = 27;\n  const LEFT_ARROW = 37;\n  const RIGHT_ARROW = 39;\n\n  export let classPrefix, element, descriptionId, firstFocusableElement,\n    focusableElements, labelId, lastFocusableElement, step, dataStepId;\n\n  let hasCancelIcon, hasTitle, classes;\n\n  $: {\n    hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled;\n    hasTitle = step.options && step.options.title;\n  }\n\n  export const getElement = () => element;\n\n  onMount(() => {\n    // Get all elements that are focusable\n    dataStepId = { [`data-${classPrefix}shepherd-step-id`]: step.id };\n    focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]');\n    firstFocusableElement = focusableElements[0];\n    lastFocusableElement = focusableElements[focusableElements.length - 1];\n  });\n\n  afterUpdate(() => {\n    if(classes !== step.options.classes) {\n      updateDynamicClasses();\n    }\n  });\n\n  function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n  }\n\n  function removeClasses(classes) {\n    if (isString(classes)) {\n      const oldClasses = getClassesArray(classes);\n      if (oldClasses.length) {\n        element.classList.remove(...oldClasses);\n      }\n    }\n  }\n\n  function addClasses(classes) {\n    if(isString(classes)) {\n      const newClasses = getClassesArray(classes);\n      if (newClasses.length) {\n        element.classList.add(...newClasses);\n      }\n    }\n  }\n\n  function getClassesArray(classes) {\n     return classes.split(' ').filter(className => !!className.length);\n  }\n\n  /**\n   * Setup keydown events to allow closing the modal with ESC\n   *\n   * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n   *\n   * @private\n   */\n  const handleKeyDown = (e) => {\n    const { tour } = step;\n    switch (e.keyCode) {\n      case KEY_TAB:\n        if (focusableElements.length === 0) {\n          e.preventDefault();\n          break;\n        }\n        // Backward tab\n        if (e.shiftKey) {\n          if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n            e.preventDefault();\n            lastFocusableElement.focus();\n          }\n        } else {\n          if (document.activeElement === lastFocusableElement) {\n            e.preventDefault();\n            firstFocusableElement.focus();\n          }\n        }\n        break;\n      case KEY_ESC:\n        if (tour.options.exitOnEsc) {\n          e.stopPropagation();\n          step.cancel();\n        }\n        break;\n      case LEFT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          e.stopPropagation();\n          tour.back();\n        }\n        break;\n      case RIGHT_ARROW:\n        if (tour.options.keyboardNavigation) {\n          e.stopPropagation();\n          tour.next();\n        }\n        break;\n      default:\n        break;\n    }\n  };\n</script>\n\n<style global>\n  .shepherd-element {\n    background: #fff;\n    border-radius: 5px;\n    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);\n    max-width: 400px;\n    opacity: 0;\n    outline: none;\n    transition: opacity 0.3s, visibility 0.3s;\n    visibility: hidden;\n    width: 100%;\n    z-index: 9999;\n  }\n\n  .shepherd-enabled.shepherd-element {\n    opacity: 1;\n    visibility: visible;\n  }\n\n  .shepherd-element[data-popper-reference-hidden]:not(.shepherd-centered) {\n    opacity: 0;\n    pointer-events: none;\n    visibility: hidden;\n  }\n\n  .shepherd-element, .shepherd-element *,\n  .shepherd-element *:after,\n  .shepherd-element *:before {\n    box-sizing: border-box;\n  }\n\n  .shepherd-arrow,\n  .shepherd-arrow::before {\n    position: absolute;\n    width: 16px;\n    height: 16px;\n    z-index: -1;\n  }\n\n  .shepherd-arrow:before {\n    content: '';\n    transform: rotate(45deg);\n    background: #fff  ;\n  }\n\n  .shepherd-element[data-popper-placement^='top'] > .shepherd-arrow {\n    bottom: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='bottom'] > .shepherd-arrow {\n    top: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='left'] > .shepherd-arrow {\n    right: -8px;\n  }\n\n  .shepherd-element[data-popper-placement^='right'] > .shepherd-arrow {\n    left: -8px;\n  }\n\n  .shepherd-element.shepherd-centered > .shepherd-arrow {\n    opacity: 0;\n  }\n\n\n  /**\n  * Arrow on top of tooltip centered horizontally, with title color\n  */\n  .shepherd-element.shepherd-has-title[data-popper-placement^='bottom'] > .shepherd-arrow::before {\n    background-color: #e6e6e6;\n  }\n\n  .shepherd-target-click-disabled.shepherd-enabled.shepherd-target,\n  .shepherd-target-click-disabled.shepherd-enabled.shepherd-target * {\n    pointer-events: none;\n  }\n</style>\n\n<div\n  aria-describedby={!isUndefined(step.options.text) ? descriptionId : null}\n  aria-labelledby={step.options.title ? labelId : null}\n  bind:this={element}\n  class:shepherd-has-cancel-icon=\"{hasCancelIcon}\"\n  class:shepherd-has-title=\"{hasTitle}\"\n  class:shepherd-element=\"{true}\"\n  {...dataStepId}\n  on:keydown={handleKeyDown}\n  role=\"dialog\"\n  tabindex=\"0\"\n>\n    {#if step.options.arrow && step.options.attachTo && step.options.attachTo.element && step.options.attachTo.on}\n      <div class=\"shepherd-arrow\" data-popper-arrow></div>\n    {/if}\n  <ShepherdContent\n    {descriptionId}\n    {labelId}\n    {step}\n  />\n</div>\n", "import merge from 'deepmerge';\nimport { Evented } from './evented.js';\nimport autoBind from './utils/auto-bind.js';\nimport {\n  isElement,\n  isHTMLElement,\n  isFunction,\n  isUndefined\n} from './utils/type-check.js';\nimport { bindAdvance } from './utils/bind.js';\nimport { parseAttachTo, normalizePrefix, uuid } from './utils/general.js';\nimport {\n  setupTooltip,\n  destroyTooltip,\n  mergeTooltipConfig\n} from './utils/floating-ui.js';\nimport ShepherdElement from './components/shepherd-element.svelte';\n\n/**\n * A class representing steps to be added to a tour.\n * @extends {Evented}\n */\nexport class Step extends Evented {\n  /**\n   * Create a step\n   * @param {Tour} tour The tour for the step\n   * @param {object} options The options for the step\n   * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n   * @param {object} options.attachTo The element the step should be attached to on the page.\n   * An object with properties `element` and `on`.\n   *\n   * ```js\n   * const step = new Step(tour, {\n   *   attachTo: { element: '.some .selector-path', on: 'left' },\n   *   ...moreOptions\n   * });\n   * ```\n   *\n   * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n   * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n   * in the middle of the screen, without an arrow pointing to the target.\n   * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n   * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n   * @param {string} options.attachTo.on The optional direction to place the FloatingUI tooltip relative to the element.\n   *   - Possible string values: 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n   * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n   * It should be an object with a string `selector` and an `event` name\n   * ```js\n   * const step = new Step(tour, {\n   *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n   *   ...moreOptions\n   * });\n   * ```\n   * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n   * You can also always manually advance the Tour by calling `myTour.next()`.\n   * @param {function} options.beforeShowPromise A function that returns a promise.\n   * When the promise resolves, the rest of the `show` code for the step will execute.\n   * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n   * footer below the main body text.\n   * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n   * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n   * work inside the action.\n   * You can use action to skip steps or navigate to specific steps, with something like:\n   * ```js\n   * action() {\n   *   return this.show('some_step_name');\n   * }\n   * ```\n   * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n   * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n   * @param {string} options.buttons.button.label The aria-label text of the button\n   * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n   * @param {string} options.buttons.button.text The HTML text of the button\n   * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n   * @param {object} options.cancelIcon Options for the cancel icon\n   * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n   * @param {string} options.cancelIcon.label The label to add for `aria-label`\n   * @param {string} options.classes A string of extra classes to add to the step's content element.\n   * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n   * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n   * @param {string} options.id The string to use as the `id` for the step.\n   * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n   * @param {number | { topLeft: number, bottomLeft: number, bottomRight: number, topRight: number }} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n   * @param {object} options.floatingUIOptions Extra options to pass to FloatingUI\n   * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n   * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n   * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n   * define a custom action to do the scrolling, and possibly other logic.\n   * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n   * If it returns false, the step will be skipped.\n   * @param {string} options.text The text in the body of the step. It can be one of three types:\n   * ```\n   * - HTML string\n   * - `HTMLElement` object\n   * - `Function` to be executed when the step is built. It must return one the two options above.\n   * ```\n   * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n   * ```\n   * - HTML string\n   * - `Function` to be executed when the step is built. It must return HTML string.\n   * ```\n   * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n   * ```js\n   * when: {\n   *   show: function() {\n   *     window.scrollTo(0, 0);\n   *   }\n   * }\n   * ```\n   * @return {Step} The newly created Step instance\n   */\n  constructor(tour, options = {}) {\n    super(tour, options);\n    this.tour = tour;\n    this.classPrefix = this.tour.options\n      ? normalizePrefix(this.tour.options.classPrefix)\n      : '';\n    this.styles = tour.styles;\n\n    /**\n     * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n     * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n     * @type {null|{}|{element, to}}\n     * @private\n     */\n    this._resolvedAttachTo = null;\n\n    autoBind(this);\n\n    this._setOptions(options);\n\n    return this;\n  }\n\n  /**\n   * Cancel the tour\n   * Triggers the `cancel` event\n   */\n  cancel() {\n    this.tour.cancel();\n    this.trigger('cancel');\n  }\n\n  /**\n   * Complete the tour\n   * Triggers the `complete` event\n   */\n  complete() {\n    this.tour.complete();\n    this.trigger('complete');\n  }\n\n  /**\n   * Remove the step, delete the step's element, and destroy the FloatingUI instance for the step.\n   * Triggers `destroy` event\n   */\n  destroy() {\n    destroyTooltip(this);\n\n    if (isHTMLElement(this.el)) {\n      this.el.remove();\n      this.el = null;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('destroy');\n  }\n\n  /**\n   * Returns the tour for the step\n   * @return {Tour} The tour instance\n   */\n  getTour() {\n    return this.tour;\n  }\n\n  /**\n   * Hide the step\n   */\n  hide() {\n    this.tour.modal.hide();\n\n    this.trigger('before-hide');\n\n    if (this.el) {\n      this.el.hidden = true;\n    }\n\n    this._updateStepTargetOnHide();\n\n    this.trigger('hide');\n  }\n\n  /**\n   * Resolves attachTo options.\n   * @returns {{}|{element, on}}\n   * @private\n   */\n  _resolveAttachToOptions() {\n    this._resolvedAttachTo = parseAttachTo(this);\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * A selector for resolved attachTo options.\n   * @returns {{}|{element, on}}\n   * @private\n   */\n  _getResolvedAttachToOptions() {\n    if (this._resolvedAttachTo === null) {\n      return this._resolveAttachToOptions();\n    }\n\n    return this._resolvedAttachTo;\n  }\n\n  /**\n   * Check if the step is open and visible\n   * @return {boolean} True if the step is open and visible\n   */\n  isOpen() {\n    return Boolean(this.el && !this.el.hidden);\n  }\n\n  /**\n   * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n   * @return {*|Promise}\n   */\n  show() {\n    if (isFunction(this.options.beforeShowPromise)) {\n      return Promise.resolve(this.options.beforeShowPromise()).then(() =>\n        this._show()\n      );\n    }\n    return Promise.resolve(this._show());\n  }\n\n  /**\n   * Updates the options of the step.\n   *\n   * @param {Object} options The options for the step\n   */\n  updateStepOptions(options) {\n    Object.assign(this.options, options);\n\n    if (this.shepherdElementComponent) {\n      this.shepherdElementComponent.$set({ step: this });\n    }\n  }\n\n  /**\n   * Returns the element for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n   */\n  getElement() {\n    return this.el;\n  }\n\n  /**\n   * Returns the target for the step\n   * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n   */\n  getTarget() {\n    return this.target;\n  }\n\n  /**\n   * Creates Shepherd element for step based on options\n   *\n   * @return {Element} The DOM element for the step tooltip\n   * @private\n   */\n  _createTooltipContent() {\n    const descriptionId = `${this.id}-description`;\n    const labelId = `${this.id}-label`;\n\n    this.shepherdElementComponent = new ShepherdElement({\n      target: this.tour.options.stepsContainer || document.body,\n      props: {\n        classPrefix: this.classPrefix,\n        descriptionId,\n        labelId,\n        step: this,\n        styles: this.styles\n      }\n    });\n\n    return this.shepherdElementComponent.getElement();\n  }\n\n  /**\n   * If a custom scrollToHandler is defined, call that, otherwise do the generic\n   * scrollIntoView call.\n   *\n   * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n   * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n   * @private\n   */\n  _scrollTo(scrollToOptions) {\n    const { element } = this._getResolvedAttachToOptions();\n\n    if (isFunction(this.options.scrollToHandler)) {\n      this.options.scrollToHandler(element);\n    } else if (\n      isElement(element) &&\n      typeof element.scrollIntoView === 'function'\n    ) {\n      element.scrollIntoView(scrollToOptions);\n    }\n  }\n\n  /**\n   * _getClassOptions gets all possible classes for the step\n   * @param {Object} stepOptions The step specific options\n   * @returns {String} unique string from array of classes\n   * @private\n   */\n  _getClassOptions(stepOptions) {\n    const defaultStepOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n    const stepClasses = stepOptions.classes ? stepOptions.classes : '';\n    const defaultStepOptionsClasses =\n      defaultStepOptions && defaultStepOptions.classes\n        ? defaultStepOptions.classes\n        : '';\n    const allClasses = [\n      ...stepClasses.split(' '),\n      ...defaultStepOptionsClasses.split(' ')\n    ];\n    const uniqClasses = new Set(allClasses);\n\n    return Array.from(uniqClasses).join(' ').trim();\n  }\n\n  /**\n   * Sets the options for the step, maps `when` to events, sets up buttons\n   * @param {Object} options The options for the step\n   * @private\n   */\n  _setOptions(options = {}) {\n    let tourOptions =\n      this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n\n    tourOptions = merge({}, tourOptions || {});\n\n    this.options = Object.assign(\n      {\n        arrow: true\n      },\n      tourOptions,\n      options,\n      mergeTooltipConfig(tourOptions, options)\n    );\n\n    const { when } = this.options;\n\n    this.options.classes = this._getClassOptions(options);\n\n    this.destroy();\n    this.id = this.options.id || `step-${uuid()}`;\n\n    if (when) {\n      Object.keys(when).forEach((event) => {\n        this.on(event, when[event], this);\n      });\n    }\n  }\n\n  /**\n   * Create the element and set up the FloatingUI instance\n   * @private\n   */\n  _setupElements() {\n    if (!isUndefined(this.el)) {\n      this.destroy();\n    }\n\n    this.el = this._createTooltipContent();\n\n    if (this.options.advanceOn) {\n      bindAdvance(this);\n    }\n\n    // The tooltip implementation details are handled outside of the Step\n    // object.\n    setupTooltip(this);\n  }\n\n  /**\n   * Triggers `before-show`, generates the tooltip DOM content,\n   * sets up a FloatingUI instance for the tooltip, then triggers `show`.\n   * @private\n   */\n  _show() {\n    this.trigger('before-show');\n\n    // Force resolve to make sure the options are updated on subsequent shows.\n    this._resolveAttachToOptions();\n    this._setupElements();\n\n    if (!this.tour.modal) {\n      this.tour._setupModal();\n    }\n\n    this.tour.modal.setupForStep(this);\n    this._styleTargetElementForStep(this);\n    this.el.hidden = false;\n\n    // start scrolling to target before showing the step\n    if (this.options.scrollTo) {\n      setTimeout(() => {\n        this._scrollTo(this.options.scrollTo);\n      });\n    }\n\n    this.el.hidden = false;\n\n    const content = this.shepherdElementComponent.getElement();\n    const target = this.target || document.body;\n    target.classList.add(`${this.classPrefix}shepherd-enabled`);\n    target.classList.add(`${this.classPrefix}shepherd-target`);\n    content.classList.add('shepherd-enabled');\n\n    this.trigger('show');\n  }\n\n  /**\n   * Modulates the styles of the passed step's target element, based on the step's options and\n   * the tour's `modal` option, to visually emphasize the element\n   *\n   * @param step The step object that attaches to the element\n   * @private\n   */\n  _styleTargetElementForStep(step) {\n    const targetElement = step.target;\n\n    if (!targetElement) {\n      return;\n    }\n\n    if (step.options.highlightClass) {\n      targetElement.classList.add(step.options.highlightClass);\n    }\n\n    targetElement.classList.remove('shepherd-target-click-disabled');\n\n    if (step.options.canClickTarget === false) {\n      targetElement.classList.add('shepherd-target-click-disabled');\n    }\n  }\n\n  /**\n   * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n   * and 'shepherd-target' classes\n   * @private\n   */\n  _updateStepTargetOnHide() {\n    const target = this.target || document.body;\n\n    if (this.options.highlightClass) {\n      target.classList.remove(this.options.highlightClass);\n    }\n\n    target.classList.remove(\n      'shepherd-target-click-disabled',\n      `${this.classPrefix}shepherd-enabled`,\n      `${this.classPrefix}shepherd-target`\n    );\n  }\n}\n", "/**\n * Cleanup the steps and set pointerEvents back to 'auto'\n * @param tour The tour object\n */\nexport function cleanupSteps(tour) {\n  if (tour) {\n    const { steps } = tour;\n\n    steps.forEach((step) => {\n      if (\n        step.options &&\n        step.options.canClickTarget === false &&\n        step.options.attachTo\n      ) {\n        if (step.target instanceof HTMLElement) {\n          step.target.classList.remove('shepherd-target-click-disabled');\n        }\n      }\n    });\n  }\n}\n", "/**\n * Generates the svg path data for a rounded rectangle overlay\n * @param {Object} dimension - Dimensions of rectangle.\n * @param {number} width - Width.\n * @param {number} height - Height.\n * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n * @param {number | { topLeft: number, topRight: number, bottomRight: number, bottomLeft: number }} [r=0] - Corner Radius. Keep this smaller than half of width or height.\n * @returns {string} - Rounded rectangle overlay path data.\n */\nexport function makeOverlayPath({ width, height, x = 0, y = 0, r = 0 }) {\n  const { innerWidth: w, innerHeight: h } = window;\n  const {\n    topLeft = 0,\n    topRight = 0,\n    bottomRight = 0,\n    bottomLeft = 0\n  } = typeof r === 'number'\n    ? { topLeft: r, topRight: r, bottomRight: r, bottomLeft: r }\n    : r;\n\n  return `M${w},${h}\\\nH0\\\nV0\\\nH${w}\\\nV${h}\\\nZ\\\nM${x + topLeft},${y}\\\na${topLeft},${topLeft},0,0,0-${topLeft},${topLeft}\\\nV${height + y - bottomLeft}\\\na${bottomLeft},${bottomLeft},0,0,0,${bottomLeft},${bottomLeft}\\\nH${width + x - bottomRight}\\\na${bottomRight},${bottomRight},0,0,0,${bottomRight}-${bottomRight}\\\nV${y + topRight}\\\na${topRight},${topRight},0,0,0-${topRight}-${topRight}\\\nZ`;\n}\n", "<script>\n  import { uuid } from '../utils/general.js';\n  import { makeOverlayPath } from '../utils/overlay-path.js';\n\n  export let element, openingProperties;\n  const guid = uuid();\n  let modalIsVisible = false;\n  let rafId = undefined;\n  let pathDefinition;\n\n  $: pathDefinition = makeOverlayPath(openingProperties);\n\n  closeModalOpening();\n\n  export const getElement = () => element;\n\n  export function closeModalOpening() {\n    openingProperties = {\n      width: 0,\n      height: 0,\n      x: 0,\n      y: 0,\n      r: 0\n    };\n  }\n\n  /**\n   * Hide the modal overlay\n   */\n  export function hide() {\n    modalIsVisible = false;\n\n    // Ensure we cleanup all event listeners when we hide the modal\n    _cleanupStepEventListeners();\n  }\n\n  /**\n   * Uses the bounds of the element we want the opening overtop of to set the dimensions of the opening and position it\n   * @param {Number} modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n   * @param {Number | { topLeft: Number, bottomLeft: Number, bottomRight: Number, topRight: Number }} modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n   * @param {HTMLElement} scrollParent The scrollable parent of the target element\n   * @param {HTMLElement} targetElement The element the opening will expose\n   */\n  export function positionModal(\n    modalOverlayOpeningPadding = 0,\n    modalOverlayOpeningRadius = 0,\n    scrollParent,\n    targetElement\n  ) {\n    if (targetElement) {\n      const { y, height } = _getVisibleHeight(targetElement, scrollParent);\n      const { x, width, left } = targetElement.getBoundingClientRect();\n\n      // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n      openingProperties = {\n        width: width + modalOverlayOpeningPadding * 2,\n        height: height + modalOverlayOpeningPadding * 2,\n        x: (x || left) - modalOverlayOpeningPadding,\n        y: y - modalOverlayOpeningPadding,\n        r: modalOverlayOpeningRadius\n      };\n    } else {\n      closeModalOpening();\n    }\n  }\n\n  /**\n   * If modal is enabled, setup the svg mask opening and modal overlay for the step\n   * @param {Step} step The step instance\n   */\n  export function setupForStep(step) {\n    // Ensure we move listeners from the previous step, before we setup new ones\n    _cleanupStepEventListeners();\n\n    if (step.tour.options.useModalOverlay) {\n      _styleForStep(step);\n      show();\n    } else {\n      hide();\n    }\n  }\n\n  /**\n   * Show the modal overlay\n   */\n  export function show() {\n    modalIsVisible = true;\n  }\n\n  const _preventModalBodyTouch = (e) => {\n    e.preventDefault();\n  };\n\n  const _preventModalOverlayTouch = (e) => {\n    e.stopPropagation();\n  };\n\n  /**\n   * Add touchmove event listener\n   * @private\n   */\n  function _addStepEventListeners() {\n    // Prevents window from moving on touch.\n    window.addEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  /**\n   * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n   * @private\n   */\n  function _cleanupStepEventListeners() {\n    if (rafId) {\n      cancelAnimationFrame(rafId);\n      rafId = undefined;\n    }\n\n    window.removeEventListener('touchmove', _preventModalBodyTouch, {\n      passive: false\n    });\n  }\n\n  /**\n   * Style the modal for the step\n   * @param {Step} step The step to style the opening for\n   * @private\n   */\n  function _styleForStep(step) {\n    const {\n      modalOverlayOpeningPadding,\n      modalOverlayOpeningRadius\n    } = step.options;\n\n    const scrollParent = _getScrollParent(step.target);\n\n    // Setup recursive function to call requestAnimationFrame to update the modal opening position\n    const rafLoop = () => {\n      rafId = undefined;\n      positionModal(\n        modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius,\n        scrollParent,\n        step.target\n      );\n      rafId = requestAnimationFrame(rafLoop);\n    };\n\n    rafLoop();\n\n    _addStepEventListeners();\n  }\n\n  /**\n   * Find the closest scrollable parent element\n   * @param {HTMLElement} element The target element\n   * @returns {HTMLElement}\n   * @private\n   */\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n\n    const isHtmlElement = element instanceof HTMLElement;\n    const overflowY =\n      isHtmlElement && window.getComputedStyle(element).overflowY;\n    const isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n\n    return _getScrollParent(element.parentElement);\n  }\n\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n  function _getVisibleHeight(element, scrollParent) {\n    const elementRect = element.getBoundingClientRect();\n    let top = elementRect.y || elementRect.top;\n    let bottom = elementRect.bottom || top + elementRect.height;\n\n    if (scrollParent) {\n      const scrollRect = scrollParent.getBoundingClientRect();\n      const scrollTop = scrollRect.y || scrollRect.top;\n      const scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n\n    const height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return { y: top, height };\n  }\n</script>\n\n<svg\n  bind:this={element}\n  class={`${\n    modalIsVisible ? 'shepherd-modal-is-visible' : ''\n  } shepherd-modal-overlay-container`}\n  on:touchmove={_preventModalOverlayTouch}\n>\n  <path d={pathDefinition} />\n</svg>\n\n<style global>\n  .shepherd-modal-overlay-container {\n    height: 0;\n    left: 0;\n    opacity: 0;\n    overflow: hidden;\n    pointer-events: none;\n    position: fixed;\n    top: 0;\n    transition: all 0.3s ease-out, height 0ms 0.3s, opacity 0.3s 0ms;\n    width: 100vw;\n    z-index: 9997;\n  }\n\n  .shepherd-modal-overlay-container.shepherd-modal-is-visible {\n    height: 100vh;\n    opacity: 0.5;\n    transition: all 0.3s ease-out, height 0s 0s, opacity 0.3s 0s;\n    transform: translateZ(0);\n  }\n\n  .shepherd-modal-overlay-container.shepherd-modal-is-visible path {\n    pointer-events: all;\n  }\n</style>\n", "import { Evented } from './evented.js';\nimport { Step } from './step.js';\nimport autoBind from './utils/auto-bind.js';\nimport {\n  isHTMLElement,\n  isFunction,\n  isString,\n  isUndefined\n} from './utils/type-check.js';\nimport { cleanupSteps } from './utils/cleanup.js';\nimport { normalizePrefix, uuid } from './utils/general.js';\nimport ShepherdModal from './components/shepherd-modal.svelte';\n\nconst Shepherd = new Evented();\n\n/**\n * Class representing the site tour\n * @extends {Evented}\n */\nexport class Tour extends Evented {\n  /**\n   * @param {Object} options The options for the tour\n   * @param {boolean | function(): boolean | Promise<boolean> | function(): Promise<boolean>} options.confirmCancel If true, will issue a `window.confirm` before cancelling.\n   * If it is a function(support Async Function), it will be called and wait for the return value, and will only be cancelled if the value returned is true\n   * @param {string} options.confirmCancelMessage The message to display in the `window.confirm` dialog\n   * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n   * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n   * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n   * set to false.\n   * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n   * unless this is explicitly set to false.\n   * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n   * If not set, the steps will be appended to `document.body`.\n   * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n   * If not set, the modal will be appended to `document.body`.\n   * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n   * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n   * dynamically generated `id` property.\n   * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n   * modal overlay. If true, the overlay will create an opening around the target element so that it\n   * can remain interactive\n   * @returns {Tour}\n   */\n  constructor(options = {}) {\n    super(options);\n\n    autoBind(this);\n\n    const defaultTourOptions = {\n      exitOnEsc: true,\n      keyboardNavigation: true\n    };\n\n    this.options = Object.assign({}, defaultTourOptions, options);\n    this.classPrefix = normalizePrefix(this.options.classPrefix);\n    this.steps = [];\n    this.addSteps(this.options.steps);\n\n    // Pass these events onto the global Shepherd object\n    const events = [\n      'active',\n      'cancel',\n      'complete',\n      'inactive',\n      'show',\n      'start'\n    ];\n    events.map((event) => {\n      ((e) => {\n        this.on(e, (opts) => {\n          opts = opts || {};\n          opts.tour = this;\n          Shepherd.trigger(e, opts);\n        });\n      })(event);\n    });\n\n    this._setTourID();\n\n    return this;\n  }\n\n  /**\n   * Adds a new step to the tour\n   * @param {Object|Step} options An object containing step options or a Step instance\n   * @param {number} index The optional index to insert the step at. If undefined, the step\n   * is added to the end of the array.\n   * @return {Step} The newly added step\n   */\n  addStep(options, index) {\n    let step = options;\n\n    if (!(step instanceof Step)) {\n      step = new Step(this, step);\n    } else {\n      step.tour = this;\n    }\n\n    if (!isUndefined(index)) {\n      this.steps.splice(index, 0, step);\n    } else {\n      this.steps.push(step);\n    }\n\n    return step;\n  }\n\n  /**\n   * Add multiple steps to the tour\n   * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n   */\n  addSteps(steps) {\n    if (Array.isArray(steps)) {\n      steps.forEach((step) => {\n        this.addStep(step);\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Go to the previous step in the tour\n   */\n  back() {\n    const index = this.steps.indexOf(this.currentStep);\n    this.show(index - 1, false);\n  }\n\n  /**\n   * Calls _done() triggering the 'cancel' event\n   * If `confirmCancel` is true, will show a window.confirm before cancelling\n   * If `confirmCancel` is a function, will call it and wait for the return value,\n   * and only cancel when the value returned is true\n   */\n  async cancel() {\n    if (this.options.confirmCancel) {\n      const confirmCancelIsFunction =\n        typeof this.options.confirmCancel === 'function';\n      const cancelMessage =\n        this.options.confirmCancelMessage ||\n        'Are you sure you want to stop the tour?';\n      const stopTour = confirmCancelIsFunction\n        ? await this.options.confirmCancel()\n        : window.confirm(cancelMessage);\n      if (stopTour) {\n        this._done('cancel');\n      }\n    } else {\n      this._done('cancel');\n    }\n  }\n\n  /**\n   * Calls _done() triggering the `complete` event\n   */\n  complete() {\n    this._done('complete');\n  }\n\n  /**\n   * Gets the step from a given id\n   * @param {Number|String} id The id of the step to retrieve\n   * @return {Step} The step corresponding to the `id`\n   */\n  getById(id) {\n    return this.steps.find((step) => {\n      return step.id === id;\n    });\n  }\n\n  /**\n   * Gets the current step\n   * @returns {Step|null}\n   */\n  getCurrentStep() {\n    return this.currentStep;\n  }\n\n  /**\n   * Hide the current step\n   */\n  hide() {\n    const currentStep = this.getCurrentStep();\n\n    if (currentStep) {\n      return currentStep.hide();\n    }\n  }\n\n  /**\n   * Check if the tour is active\n   * @return {boolean}\n   */\n  isActive() {\n    return Shepherd.activeTour === this;\n  }\n\n  /**\n   * Go to the next step in the tour\n   * If we are at the end, call `complete`\n   */\n  next() {\n    const index = this.steps.indexOf(this.currentStep);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      this.show(index + 1, true);\n    }\n  }\n\n  /**\n   * Removes the step from the tour\n   * @param {String} name The id for the step to remove\n   */\n  removeStep(name) {\n    const current = this.getCurrentStep();\n\n    // Find the step, destroy it and remove it from this.steps\n    this.steps.some((step, i) => {\n      if (step.id === name) {\n        if (step.isOpen()) {\n          step.hide();\n        }\n\n        step.destroy();\n        this.steps.splice(i, 1);\n\n        return true;\n      }\n    });\n\n    if (current && current.id === name) {\n      this.currentStep = undefined;\n\n      // If we have steps left, show the first one, otherwise just cancel the tour\n      this.steps.length ? this.show(0) : this.cancel();\n    }\n  }\n\n  /**\n   * Show a specific step in the tour\n   * @param {Number|String} key The key to look up the step by\n   * @param {Boolean} forward True if we are going forward, false if backward\n   */\n  show(key = 0, forward = true) {\n    const step = isString(key) ? this.getById(key) : this.steps[key];\n\n    if (step) {\n      this._updateStateBeforeShow();\n\n      const shouldSkipStep =\n        isFunction(step.options.showOn) && !step.options.showOn();\n\n      // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n      if (shouldSkipStep) {\n        this._skipStep(step, forward);\n      } else {\n        this.trigger('show', {\n          step,\n          previous: this.currentStep\n        });\n\n        this.currentStep = step;\n        step.show();\n      }\n    }\n  }\n\n  /**\n   * Start the tour\n   */\n  start() {\n    this.trigger('start');\n\n    // Save the focused element before the tour opens\n    this.focusedElBeforeOpen = document.activeElement;\n\n    this.currentStep = null;\n\n    this._setupModal();\n\n    this._setupActiveTour();\n    this.next();\n  }\n\n  /**\n   * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n   * @param {String} event The event name to trigger\n   * @private\n   */\n  _done(event) {\n    const index = this.steps.indexOf(this.currentStep);\n    if (Array.isArray(this.steps)) {\n      this.steps.forEach((step) => step.destroy());\n    }\n\n    cleanupSteps(this);\n\n    this.trigger(event, { index });\n\n    Shepherd.activeTour = null;\n    this.trigger('inactive', { tour: this });\n\n    if (this.modal) {\n      this.modal.hide();\n    }\n\n    if (event === 'cancel' || event === 'complete') {\n      if (this.modal) {\n        const modalContainer = document.querySelector(\n          '.shepherd-modal-overlay-container'\n        );\n\n        if (modalContainer) {\n          modalContainer.remove();\n        }\n      }\n    }\n\n    // Focus the element that was focused before the tour started\n    if (isHTMLElement(this.focusedElBeforeOpen)) {\n      this.focusedElBeforeOpen.focus();\n    }\n  }\n\n  /**\n   * Make this tour \"active\"\n   * @private\n   */\n  _setupActiveTour() {\n    this.trigger('active', { tour: this });\n\n    Shepherd.activeTour = this;\n  }\n\n  /**\n   * _setupModal create the modal container and instance\n   * @private\n   */\n  _setupModal() {\n    this.modal = new ShepherdModal({\n      target: this.options.modalContainer || document.body,\n      props: {\n        classPrefix: this.classPrefix,\n        styles: this.styles\n      }\n    });\n  }\n\n  /**\n   * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n   * @param {Step} step The step to skip\n   * @param {Boolean} forward True if we are going forward, false if backward\n   * @private\n   */\n  _skipStep(step, forward) {\n    const index = this.steps.indexOf(step);\n\n    if (index === this.steps.length - 1) {\n      this.complete();\n    } else {\n      const nextIndex = forward ? index + 1 : index - 1;\n      this.show(nextIndex, forward);\n    }\n  }\n\n  /**\n   * Before showing, hide the current step and if the tour is not\n   * already active, call `this._setupActiveTour`.\n   * @private\n   */\n  _updateStateBeforeShow() {\n    if (this.currentStep) {\n      this.currentStep.hide();\n    }\n\n    if (!this.isActive()) {\n      this._setupActiveTour();\n    }\n  }\n\n  /**\n   * Sets this.id to `${tourName}--${uuid}`\n   * @private\n   */\n  _setTourID() {\n    const tourName = this.options.tourName || 'tour';\n\n    this.id = `${tourName}--${uuid()}`;\n  }\n}\n\nexport { Shepherd };\n", "import { Step } from './step.js';\nimport { Shepherd, Tour } from './tour.js';\n\nconst isServerSide = typeof window === 'undefined';\n\nclass NoOp {\n  constructor() {}\n}\n\nif (isServerSide) {\n  Object.assign(Shepherd, { Tour: NoOp, Step: NoOp });\n} else {\n  Object.assign(Shepherd, { Tour, Step });\n}\n\nexport default Shepherd;\n"],
  "mappings": "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",
  "names": ["isMergeableObject", "value", "isNonNullObject", "isSpecial", "stringValue", "Object", "prototype", "toString", "call", "isReactElement", "canUseSymbol", "Symbol", "for", "REACT_ELEMENT_TYPE", "$$typeof", "emptyTarget", "val", "Array", "isArray", "cloneUnlessOtherwiseSpecified", "options", "clone", "deepmerge", "defaultArrayMerge", "target", "source", "concat", "map", "element", "getMergeFunction", "key", "customMerge", "getEnumerableOwnPropertySymbols", "getOwnPropertySymbols", "filter", "symbol", "propertyIsEnumerable", "getKeys", "keys", "propertyIsOnObject", "object", "property", "_", "propertyIsUnsafe", "hasOwnProperty", "mergeObject", "destination", "forEach", "arrayMerge", "sourceIsArray", "targetIsArray", "sourceAndTargetTypesMatch", "all", "deepmergeAll", "array", "Error", "reduce", "prev", "next", "deepmerge_1", "cjs", "isElement", "Element", "isHTMLElement", "HTMLElement", "isFunction", "isString", "isUndefined", "undefined", "Evented", "on", "event", "handler", "ctx", "once", "bindings", "push", "off", "binding", "index", "splice", "trigger", "args", "context", "apply", "autoBind", "self", "getOwnPropertyNames", "constructor", "i", "length", "bind", "_setupAdvanceOnHandler", "selector", "step", "isOpen", "targetIsEl", "el", "currentTarget", "targetIsSelector", "matches", "tour", "bindAdvance", "advanceOn", "document", "querySelector", "e", "console", "error", "addEventListener", "removeEventListener", "body", "normalizePrefix", "prefix", "charAt", "parseAttachTo", "attachTo", "returnOpts", "assign", "shouldCenterStep", "resolvedAttachToOptions", "uuid", "d", "Date", "now", "replace", "c", "r", "Math", "random", "floor", "min", "max", "round", "createCoords", "v", "x", "y", "oppositeSideMap", "left", "right", "bottom", "top", "oppositeAlignmentMap", "start", "end", "clamp", "evaluate", "param", "getSide", "placement", "split", "getAlignment", "getOppositeAxis", "axis", "getAxisLength", "getSideAxis", "includes", "getAlignmentAxis", "getAlignmentSides", "rects", "rtl", "alignment", "alignmentAxis", "mainAlignmentSide", "reference", "floating", "getOppositePlacement", "getExpandedPlacements", "oppositePlacement", "getOppositeAlignmentPlacement", "getSideList", "side", "isStart", "lr", "rl", "tb", "bt", "getOppositeAxisPlacements", "flipAlignment", "direction", "list", "expandPaddingObject", "padding", "_extends", "getPaddingObject", "rectToClientRect", "rect", "width", "height", "computeCoordsFromPlacement", "_ref", "sideAxis", "alignLength", "isVertical", "commonX", "commonY", "commonAlign", "coords", "computePosition", "config", "strategy", "middleware", "platform", "validMiddleware", "Boolean", "isRTL", "getElementRects", "statefulPlacement", "middlewareData", "resetCount", "name", "fn", "nextX", "nextY", "data", "reset", "initialPlacement", "elements", "detectOverflow", "state", "_await$platform$isEle", "boundary", "rootBoundary", "elementContext", "altBoundary", "paddingObject", "altContext", "clippingClientRect", "getClippingRect", "contextElement", "getDocumentElement", "offsetParent", "getOffsetParent", "offsetScale", "getScale", "elementClientRect", "convertOffsetParentRelativeRectToViewportRelativeRect", "arrow", "arrowDimensions", "getDimensions", "isYAxis", "minProp", "maxProp", "clientProp", "endDiff", "startDiff", "arrowOffsetParent", "clientSize", "centerToReference", "largestPossiblePadding", "minPadding", "maxPadding", "min$1", "center", "offset", "shouldAddOffset", "alignmentOffset", "centerOffset", "flip", "_middlewareData$flip", "_evaluate2", "mainAxis", "checkMainAxis", "crossAxis", "checkCrossAxis", "fallbackPlacements", "specifiedFallbackPlacements", "fallbackStrategy", "fallbackAxisSideDirection", "detectOverflowOptions", "_objectWithoutPropertiesLoose", "_excluded2", "isBasePlacement", "placements", "overflow", "overflows", "overflowsData", "sides", "every", "_middlewareData$flip2", "_overflowsData$filter", "nextIndex", "nextPlacement", "resetPlacement", "sort", "a", "b", "_overflowsData$map$so", "acc", "shift", "_evaluate4", "limiter", "_excluded4", "mainAxisCoord", "crossAxisCoord", "minSide", "maxSide", "limitedCoords", "limitShift", "rawOffset", "computedOffset", "len", "limitMin", "limitMax", "_middlewareData$offse", "_middlewareData$offse2", "isOriginSide", "getNodeName", "node", "isNode", "nodeName", "toLowerCase", "getWindow", "_node$ownerDocument", "ownerDocument", "defaultView", "window", "documentElement", "Node", "isShadowRoot", "ShadowRoot", "isOverflowElement", "overflowX", "overflowY", "display", "getComputedStyle", "test", "isTableElement", "isContainingBlock", "webkit", "isWebKit", "css", "transform", "perspective", "containerType", "backdropFilter", "some", "willChange", "contain", "getContainingBlock", "currentNode", "getParentNode", "isLastTraversableNode", "CSS", "supports", "getNodeScroll", "scrollLeft", "scrollTop", "pageXOffset", "pageYOffset", "result", "assignedSlot", "parentNode", "host", "getNearestOverflowAncestor", "getOverflowAncestors", "_node$ownerDocument2", "scrollableAncestor", "isBody", "win", "visualViewport", "getCssDimensions", "parseFloat", "hasOffset", "offsetWidth", "offsetHeight", "shouldFallback", "$", "unwrapElement", "domElement", "getBoundingClientRect", "Number", "isFinite", "noOffsets", "getVisualOffsets", "offsetLeft", "offsetTop", "shouldAddVisualOffsets", "isFixed", "floatingOffsetParent", "includeScale", "isFixedStrategy", "clientRect", "scale", "visualOffsets", "offsetWin", "currentIFrame", "frameElement", "iframeScale", "iframeRect", "clientLeft", "paddingLeft", "clientTop", "paddingTop", "isOffsetParentAnElement", "scroll", "offsets", "offsetRect", "getClientRects", "from", "getWindowScrollBarX", "getDocumentRect", "html", "scrollWidth", "clientWidth", "scrollHeight", "clientHeight", "getViewportRect", "visualViewportBased", "getInnerBoundingClientRect", "getClientRectFromClippingAncestor", "clippingAncestor", "hasFixedPositionAncestor", "stopNode", "position", "getClippingElementAncestors", "cache", "cachedResult", "get", "currentContainingBlockComputedStyle", "elementIsFixed", "computedStyle", "currentNodeIsContaining", "shouldDropCurrentNode", "ancestor", "set", "elementClippingAncestors", "_c", "clippingAncestors", "firstClippingAncestor", "clippingRect", "accRect", "getRectRelativeToOffsetParent", "getTrueOffsetParent", "polyfill", "getOffsetParentFn", "getDimensionsFn", "observeMove", "onMove", "io", "timeoutId", "root", "cleanup", "clearTimeout", "disconnect", "refresh", "skip", "threshold", "insetTop", "insetRight", "insetBottom", "insetLeft", "rootMargin", "isFirstUpdate", "handleObserve", "entries", "ratio", "intersectionRatio", "setTimeout", "IntersectionObserver", "observe", "autoUpdate", "update", "ancestorScroll", "ancestorResize", "elementResize", "ResizeObserver", "layoutShift", "animationFrame", "referenceEl", "ancestors", "passive", "cleanupIo", "reobserveFrame", "resizeObserver", "firstEntry", "unobserve", "cancelAnimationFrame", "requestAnimationFrame", "frameId", "prevRefRect", "frameLoop", "nextRefRect", "Map", "mergedOptions", "platformWithCache", "computePosition$1", "setupTooltip", "attachToOptions", "_getResolvedAttachToOptions", "floatingUIOptions", "getFloatingUIOptions", "shouldCenter", "content", "shepherdElementComponent", "getElement", "classList", "add", "setPosition", "mergeTooltipConfig", "tourOptions", "merge", "destroyTooltip", "then", "floatingUIposition", "Promise", "resolve", "focus", "preventScroll", "style", "dataset", "popperPlacement", "placeArrow", "arrowEl", "arrowX", "arrowY", "addArrow", "noop", "tar", "src", "k", "run", "blank_object", "create", "run_all", "fns", "is_function", "thing", "safe_not_equal", "is_empty", "obj", "append", "appendChild", "insert", "anchor", "insertBefore", "detach", "removeChild", "destroy_each", "iterations", "detaching", "createElement", "svg_element", "createElementNS", "text", "createTextNode", "space", "empty", "listen", "attr", "attribute", "removeAttribute", "getAttribute", "setAttribute", "always_set_through_set_attribute", "set_attributes", "attributes", "descriptors", "getOwnPropertyDescriptors", "__proto__", "cssText", "indexOf", "children", "childNodes", "toggle_class", "toggle", "current_component", "set_current_component", "component", "get_current_component", "onMount", "$$", "on_mount", "afterUpdate", "after_update", "dirty_components", "binding_callbacks", "render_callbacks", "flush_callbacks", "resolved_promise", "update_scheduled", "schedule_update", "flush", "add_render_callback", "seen_callbacks", "Set", "flushidx", "saved_component", "pop", "callback", "has", "clear", "fragment", "before_update", "dirty", "p", "flush_render_callbacks", "filtered", "targets", "outroing", "outros", "group_outros", "check_outros", "transition_in", "block", "local", "delete", "transition_out", "o", "get_spread_update", "levels", "updates", "to_null_out", "accounted_for", "$$scope", "n", "create_component", "mount_component", "customElement", "m", "new_on_destroy", "on_destroy", "destroy_component", "make_dirty", "fill", "init", "instance", "create_fragment", "not_equal", "props", "append_styles", "parent_component", "bound", "on_disconnect", "callbacks", "skip_bound", "ready", "ret", "rest", "hydrate", "nodes", "l", "intro", "SvelteComponent", "$destroy", "$on", "type", "$set", "$$props", "$$set", "button", "button_class_value", "arguments", "action", "classes", "disabled", "label", "secondary", "getConfigOption", "option", "$$invalidate", "each_blocks", "create_if_block", "footer", "buttons", "button_aria_label_value", "span", "cancelIcon", "handleCancelClick", "preventDefault", "cancel", "h3", "labelId", "title", "innerHTML", "$$value", "create_if_block_1", "enabled", "header", "div", "descriptionId", "show_if_2", "show_if_1", "show_if", "div_aria_describedby_value", "current", "KEY_TAB", "KEY_ESC", "LEFT_ARROW", "RIGHT_ARROW", "getClassesArray", "className", "classPrefix", "firstFocusableElement", "focusableElements", "lastFocusableElement", "dataStepId", "hasCancelIcon", "hasTitle", "id", "querySelectorAll", "updateDynamicClasses", "removeClasses", "addClasses", "oldClasses", "remove", "newClasses", "handleKeyDown", "keyCode", "shiftKey", "activeElement", "contains", "exitOnEsc", "stopPropagation", "keyboardNavigation", "back", "Step", "styles", "_resolvedAttachTo", "_setOptions", "complete", "destroy", "_updateStepTargetOnHide", "getTour", "hide", "modal", "hidden", "_resolveAttachToOptions", "show", "beforeShowPromise", "_show", "updateStepOptions", "getTarget", "_createTooltipContent", "ShepherdElement", "stepsContainer", "_scrollTo", "scrollToOptions", "scrollToHandler", "scrollIntoView", "_getClassOptions", "stepOptions", "defaultStepOptions", "stepClasses", "defaultStepOptionsClasses", "allClasses", "uniqClasses", "join", "trim", "when", "_setupElements", "_setupModal", "setupForStep", "_styleTargetElementForStep", "scrollTo", "targetElement", "highlightClass", "canClickTarget", "cleanupSteps", "steps", "makeOverlayPath", "innerWidth", "w", "innerHeight", "h", "topLeft", "topRight", "bottomRight", "bottomLeft", "svg", "path", "_getScrollParent", "isHtmlElement", "isScrollable", "parentElement", "_getVisibleHeight", "scrollParent", "elementRect", "scrollRect", "scrollBottom", "openingProperties", "modalIsVisible", "rafId", "pathDefinition", "closeModalOpening", "_cleanupStepEventListeners", "positionModal", "modalOverlayOpeningPadding", "modalOverlayOpeningRadius", "useModalOverlay", "_styleForStep", "_preventModalBodyTouch", "_preventModalOverlayTouch", "_addStepEventListeners", "rafLoop", "Shepherd", "Tour", "defaultTourOptions", "addSteps", "events", "opts", "_setTourID", "addStep", "currentStep", "confirmCancel", "confirmCancelIsFunction", "cancelMessage", "confirmCancelMessage", "stopTour", "confirm", "_done", "getById", "find", "getCurrentStep", "isActive", "activeTour", "removeStep", "forward", "_updateStateBeforeShow", "shouldSkipStep", "showOn", "_skipStep", "previous", "focusedElBeforeOpen", "_setupActiveTour", "modalContainer", "ShepherdModal", "tourName", "isServerSide", "NoOp"]
}
